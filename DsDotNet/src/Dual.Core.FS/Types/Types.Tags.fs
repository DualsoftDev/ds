namespace Dual.Core.Types


open System.Diagnostics
open System.Collections.Generic
open System.Linq
open Newtonsoft.Json
open Dual.Common
open ActivePattern
open Microsoft.FSharp.Collections
open Dual.Core.Prelude
open System
open FSharpPlus
open Dual.Core.Prelude.IEC61131

module internal PLCTagForwardM =
    let getFullName = ForwardDecl.declare<NamedNodeLeaf -> string>


/// PLC tag 의 정보
/// PLCTag 관련 파일 : 
/// DM.NamedObject.Module.fs(PLCTagValidationError)
/// Types.Tags.fs
/// Types.Module.fs(=PLCTagM)
/// DM.Tag.Module.fs
[<DebuggerDisplay("{FullName} {StringAddress}")>]
type PLCTag private (tag, ioType, address, properties:(string*_) array, _unusedArg) as this =
    inherit NamedNodeLeaf(tag, None, properties, tag)

    let getAddress (addr: Address option) =
        match addr with
        | Some(a) -> a.GetAddress()
        | None -> ""
    /// convert string address to Address type.  Same as AddressM.tryParse
    static let s2a (addr:string) =
        if addr.isNullOrEmpty()
        then None
        else Some(Address.FromString(addr))

    // 필수 속성 항목 추가
    do
        if not (this.PropertiesToDict.ContainsKey(K.FullNameRule)) then
            this.PropertiesToDict.Add(K.FullNameRule, box(FullNameRule.AREA_TYPE_DEVICE_TAG))
        if not (this.PropertiesToDict.ContainsKey(K.SelfHold)) then
            this.PropertiesToDict.Add(K.SelfHold, box(false))
        if not (this.PropertiesToDict.ContainsKey(K.TagType)) then
            this.PropertiesToDict.Add(K.TagType, box(ioType))
        if not (this.PropertiesToDict.ContainsKey(K.Address)) then
            this.PropertiesToDict.Add(K.Address, box(address))


    (*
     * t=tag, on=origName, iot=ioType, a=address, ps=properties
     *)     
    new (t, iot, a, ps)     = PLCTag(t, iot, a, ps, 0)
    new (t, iot, a, ps)     = PLCTag(t, iot, s2a(a), ps, 0)
    new (t, iot, a)         = PLCTag(t, iot, a, [||], 0)
    new (t, iot, a)         = PLCTag(t, iot, s2a(a), [||], 0)
    new (t, iot)            = PLCTag(t, iot, None, [||], 0)
    new (t:PLCTag)          = PLCTag(t.Name, t.IOType, t.Address, t.Properties.ToArray(), 0)

    interface INamed with
        member x.Name 
            with get() = base.Name
            and set(v:string) = 
                base.Name <- v        
                x.Tag <- v
    member x.Name with get() = (x :> INamed).Name and set(v) = (x :> INamed).Name <- v

    [<JsonConstructor>]
    private new () = PLCTag(Tag(null), Some(TagType.State), None, empty)

    member val Tag:Tag = tag with get, set
    
    member x.IOType
        with get() = this.PropertiesToDict.[K.TagType] :?> TagType option
        and set(v:TagType option) = this.PropertiesToDict.[K.TagType] <- v
    
    member x.Address
        with get() = this.PropertiesToDict.[K.Address] :?> Address option
        and set(v:Address option) = this.PropertiesToDict.[K.Address] <- v

    member x.FBInstance         
        with get() =  if x.PropertiesToDict.ContainsKey(K.FBInstance) then  x.PropertiesToDict.[K.FBInstance] :?> string else ""
        and set(v:string) = x.PropertiesToDict.[K.FBInstance] <- v

    member x.Size         
        with get() =  if x.PropertiesToDict.ContainsKey(K.Size) then  x.PropertiesToDict.[K.Size] :?> Size else Size.Bit
        and set(v:Size) = x.PropertiesToDict.[K.Size] <- v

    member x.StringAddress with get() = this.PropertiesToDict.[K.Address] :?> Address option |> getAddress
    
    /// 사용자 개입 없이 Address 자동 assign 여부
    member val AutoAddress = true with get, set
    
    /// 자동 생성된 tag 여부
    member val AutoGenerated = false with get, set

    // todo : fix me    
    /// 자동 생성된 full name
    //member x.FullName with get() = !PLCTagForwardM.getFullName (x :> NamedNodeLeaf)
    member x.FullName with get() = x.Name

    override x.GetProperties() = x.PropertiesToDict |> Dict.map(fun d -> d) |> Dictionary

    override x.SetProperties(v:Dictionary<string,_>) =
        //let newobj = x.Clone (CopyPreference()) :?> PLCTag
        //let parent = x.Parent |> Option.get :?> NodeStem

        //newobj.PropertiesToDict <- v
        //let exist = (parent.getTypedCollection x).Exists newobj 

        //if exist |> not then 
        //    let oldAddress = x.PropertiesToDict.[K.Address] :?> Address option
        //    x.PropertiesToDict <- v
        //    let newAddress = v.[K.Address] :?> Address option
        //    if newAddress <> oldAddress then
        //        x.AutoAddress <- false  // property 설정에 의해 주소가 바뀐 경우, 자동 할당된 주소가 아니라 사용자가 할당한 주소로 간주
        ()

    /// children 을 제외한 자신만 복사
    override x.CloneSelf opt =
        let address =
            match opt.ChildCopyOption with
            | Shallow -> x.Address
            | Deep(offset) ->
                monad {
                    let! address = x.Address
                    let! offset = offset
                    return address.Shift offset
                }
            | DoNotCopy -> failwithlog "Invalid call!"
        let props = x.Properties |> Seq.toArray
        PLCTag(x.Name, x.IOType, address, props, AutoGenerated=true, AutoAddress=true) :> INode


    override x.ToText() = x.FullName

    override x.ToString() = x.ToText()

    override x.Equals t = 
        match t with
        | :? PLCTag as pt -> 
            x.ToText() = pt.ToText()
            && x.IOType = pt.IOType
            && x.Address = pt.Address
        | _ -> false

    interface ITag with
        member x.Address with get() = x.StringAddress
    interface IExpressionTerminal with
        member x.ToText() = x.ToText()
        member x.Equals t = x.Equals t
            


type PLCActionCommand(name:string, comd:string, [<ParamArray>] parameters:string []) =
    inherit NamedNodeLeaf(name)
    member x.Command = (comd, (parameters |> String.concat " "))


///// PLCTag 를 갖는 객체의 base class
//type TagsContainer(tags:PLCTag seq) =
//    inherit MapBasedCollectionT<PLCTag, PLCTag>( (fun (tag:PLCTag) -> tag), tags)

//    /// PLCTag 중복검사는 Key값으로 하기 힘듬
//    override x.Exists obj = 
//        let zzz =
//            x.GetEnumerable
//            |> Seq.exists(fun t -> 
//                let tagtypeA = t.GetProperties().[K.TagType] :?> TagType option
//                let tagtypeB = obj.GetProperties().[K.TagType] :?> TagType option

//                let matchAddress = 
//                    match t.Address, obj.Address with
//                    | Some(a), Some(b) -> a.GetAddrType() = b.GetAddrType()
//                    | _, _ -> true

//                let matchTagType = 
//                    match tagtypeA, tagtypeB with
//                    | Some(a), Some(b) -> a = b
//                    | _, _ -> true

//                t.Name.ToUpper() = obj.Name.ToUpper() && matchAddress && matchTagType
//                )
//        zzz

//    /// key가 이미 PLCTag 객체이니 이름 변경이 가능하면 name 값 변경
//    override x.Rename (obj:PLCTag) (name:string) =
//        let newobj = obj.Clone (CopyPreference()) :?> PLCTag
//        newobj.Name <- name 

//        let existold = x.Exists obj
//        let existnew = x.Exists newobj
//        let result = 
//            match x.Exists obj && x.Exists newobj |> not with
//            | true ->    
//                obj.Name <- name
//                true
//            | false ->
//                false

//        result
