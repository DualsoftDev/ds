namespace Engine.Core

open System
open System.Diagnostics
open System.ComponentModel

open Dual.Common.Core.FS
open Engine.Common


[<AutoOpen>]
module TagVariableModule =
    type StorageCreationParams<'T when 'T:equality> = {
        Name: string
        Value: 'T
        Address: string option
        Comment: string option
        System: ISystem option
        Target: IQualifiedNamed option
        TagKind: int
        IsGlobal: bool
        IsAutoGenerated: bool
    }

    let defaultStorageCreationParams value tagKind =
        {
            Name = ""
            Value = value
            Address = None
            Comment = None
            System = RuntimeDS.System
            Target = if tagKind > -1 then RuntimeDS.System.Cast<IQualifiedNamed>() else None
            TagKind = tagKind
            IsGlobal = false
            IsAutoGenerated = false
        }


    [<AbstractClass>]
    [<DebuggerDisplay("{Name}({Value})")>]
    type TypedValueStorage<'T when 'T:equality>(param:StorageCreationParams<'T>) =
        do
            ()  // just for debug breakpoint

        let {Name=name; Value=initValue; Address=address; Comment=comment; IsGlobal=isGlobal; IsAutoGenerated=isAutoGenerated } = param
        let mutable address = if address.IsSome then address.Value else ""
        let mutable value = initValue
        let mutable tagChanged = false
        let comment = comment |? ""

        member _.Name: string = name
        member val Address = address with get, set
        [<Browsable(false)>]
        member val IsGlobal = isGlobal with get, set
        [<Browsable(false)>]
        member val IsAutoGenerated = isAutoGenerated with get, set
        member x.Value
            with get() = value
            and set(v) =
                if value <> v then
                    value <- v
                    tagChanged <- true
                 //모델 단위로 Subscribe 에서 자신 system만 처리 (system간 TAG 링크 때문에)
                    onValueChanged((x:>IStorage).DsSystem, x, v)
                 //기존 시스템 단위로
                 //   (x:>  IStorage).DsSystem.ValueChangeSubject.OnNext(x :> IStorage, v)
        member val Comment: string = comment with get, set

        // interface IExpression<'T> 를 지원해야 하지만, 정의 위치상 구현하기 힘듦.
        // interface IExpression<'T> with ...
        // IStorage 로 casting 해서 IStorage::ToExpression extension method 를 사용하도록 한다.
        member x.ToExpression():IExpression<'T> = x.ToBoxedExpression() :?> IExpression<'T>

        /// 예지 보전 관련 정보
        member val MaintenanceInfo:IMainenance option = None with get, set

        interface IStorage with
            member x.DsSystem = param.System.Value
            member x.Target = param.Target
            member x.TagKind = param.TagKind
            member x.TagChanged  with get() = tagChanged and set(v) = tagChanged <- v
            member x.IsGlobal with get() = x.IsGlobal and set(v) = x.IsGlobal <- v
            member x.IsAutoGenerated with get() = x.IsAutoGenerated and set(v) = x.IsAutoGenerated <- v
            member x.Comment with get() = x.Comment and set(v) = x.Comment <- v
            member x.BoxedValue with get() = x.Value and set(v) = x.Value <- (v :?> 'T)
            member x.ObjValue = x.Value :> obj
            /// null 인 경우, memory 주소를 할당하지 않는다.   "" 인 경우, memory 주소를 할당한다.   다른 정상 문자열이 있으면 그대로 둔다.
            member x.Address with get() = x.Address and set(v) = x.Address <- v
            member x.ToBoxedExpression() = x.ToBoxedExpression()
            member x.CompareTo(other) = String.Compare(x.Name, (other:?>IStorage).Name)
            member x.MaintenanceInfo with get() = x.MaintenanceInfo and set(v) = x.MaintenanceInfo <- v

        interface IStorage<'T> with
            member x.Value with get() = x.Value and set(v) = x.Value <- v

        interface INamed with
            member x.Name with get() = x.Name and set(_v) = failwithlog "ERROR: not supported"

        interface IText with
            member x.ToText() = x.ToText()

        interface IType with
            member x.DataType = typedefof<'T>

        interface ITerminal with
            member x.Variable = Some(x:>IStorage)
            member x.Literal = None

        interface INamedExpressionizableTerminal with
            member x.StorageName = name


        abstract ToText: unit -> string
        /// IExpression<'T> 의 boxed 형태의 expression 생성
        abstract ToBoxedExpression : unit -> obj

    /// PLC 기준 tag 로 생성되어야 하는 것들.  e.g Counter, Timer 구조의 멤버 변수 포함 (EN, CU, CD, ..)
    /// Tag<'T> 는 address 를 갖는 tag
    [<AbstractClass>]
    type TagBase<'T when 'T:equality>(param:StorageCreationParams<'T>) =
        inherit TypedValueStorage<'T>(param)
        let {Name=name; } = param

        interface ITag<'T> with
            member val AliasNames = ResizeArray<string>()

        override x.ToText() = "$" + name
        member x.AliasNames = (x:> ITag<'T>).AliasNames


    [<AbstractClass>]
    type VariableBase<'T when 'T:equality>(param:StorageCreationParams<'T>) =
        inherit TypedValueStorage<'T>(param)

        interface IVariable<'T>
        override x.ToText() = "$" + param.Name

    type ILiteralHolder =
        inherit IExpression
        abstract ToText : unit -> string
        abstract ToTextWithoutTypeSuffix: unit -> string

    let literal2Text (x:obj) =
        match x with
        | :? bool as b -> if b then "true" else "false"
        | _ -> sprintf "%A" x

    type LiteralHolder<'T when 'T:equality> = { Value: 'T }
        with
            member x.ToText() = literal2Text (box x.Value)

            interface IExpressionizableTerminal with
                member x.ToText() = x.ToText()// sprintf "%A" x.Value
            interface ITerminal with
                member x.Variable = None
                member x.Literal = Some(x:>IExpressionizableTerminal)

            interface ILiteralHolder with
                member x.ToTextWithoutTypeSuffix() =
                    match box x.Value with
                    | :? string as s when not <| s.ToUpper().StartsWith("T#") ->
                        // string 이면서, timer 의 preset 값인 "T#1s" 와 같은 형태가 아니면, single quote 로 감싼다.
                        $"'{x.Value}'"
                    | _ -> $"{x.Value}"
                member x.ToText() = x.ToText()// sprintf "%A" x.Value
            interface IValue<'T> with
                member x.Value with get() = x.Value and set(_v) = failwithlog "ERROR: unsupported."
                member x.ObjValue = box x.Value
            interface IType with
                member x.DataType = typedefof<'T>
            interface IExpression with
                member x.BoxedEvaluatedValue = box x.Value
                member x.GetBoxedRawObject() = box x.Value
                member x.ToText() = x.ToText()
                member x.ToText(_withParenthesis:bool) = x.ToText()
                member x.FunctionName = None
                member x.FunctionSpec = None
                member x.FunctionArguments = []
                member x.WithNewFunctionArguments(_args) = failwithlog "ERROR: unsupported."
                member x.Terminal = None
                member x.CollectStorages() = []
                member x.Flatten() = failwithlog "ERROR: unsupported."
                member x.IsEqual(other) = x.Value = (other.BoxedEvaluatedValue :?> 'T)


[<AutoOpen>]
module ExpressionPrologModule =
    let mutable internal fwdSerializeFunctionNameAndBoxedArguments =
        let dummy (_functionName:string) (_args:Args) (_lambdaApplication:LambdaApplication option) (_withParenthesis:bool): string =
            failwithlog "Should be reimplemented."
        dummy

    let mutable internal fwdCreateBoolMemberVariable   = let dummy (_tagName:string) (_initValue:bool)   (_tagKind:int) : VariableBase<bool>   = failwithlog "Should be reimplemented." in dummy
    let mutable internal fwdCreateUShortMemberVariable = let dummy (_tagName:string) (_initValue:uint16) (_tagKind:int) : VariableBase<uint16> = failwithlog "Should be reimplemented." in dummy
    let mutable internal fwdCreateUInt32MemberVariable = let dummy (_tagName:string) (_initValue:uint32) (_tagKind:int) : VariableBase<uint32> = failwithlog "Should be reimplemented." in dummy

    /// 실제 구현 body 가 Engine.CodeGen.Common 에 존재
    ///
    /// FlatExpression 은 PLC 생성에서만 사용된다.
    let mutable          fwdFlattenExpression          = let dummy (_expr:IExpression)                   : IFlatExpression                     = failwithlog "Should be reimplemented." in dummy

    let clearVarBoolsOnDemand(varbools:VariableBase<bool> seq) =
        varbools
        |> filter (isItNull >> not)
        |> iter(fun vb -> vb.Value <- false)


