namespace Engine.CodeGenPLC

open System.IO
open System.Linq
open System.Runtime.CompilerServices
open Engine.Core
open Dual.Common.Core.FS
open PLC.CodeGen.LS
open PLC.CodeGen.Common
open Engine.CodeGenCPU

[<AutoOpen>]
module ExportModule =
    let generateXmlXGX
        (plcType:PlatformTarget) (system: DsSystem) (globalStorages:Storages)
        (localStorages:Storages) (pous: PouGen seq) (existingLSISprj:string option)
        (startMemory:int) (startTimer:int) (startCounter:int)
      : string =
        let projName = system.Name
        
        let getXgxPOUParams (pouName: string) (taskName: string) (pouGens: PouGen seq) =
            let pouParams: XgxPOUParams = {
                // POU name.  "DsLogic"
                POUName = pouName
                // POU container task name
                TaskName = taskName
                // POU ladder 최상단의 comment
                Comment = "DsLogic Automatically generate"
                LocalStorages = localStorages
                GlobalStorages = globalStorages
                CommentedStatements = pouGens.Collect(fun p -> p.CommentedStatements()) |> Seq.toList }

            pouParams

        let usedByteIndices =
            let getBytes addr = 
                [  
                    match plcType with
                    | XGI ->
                        match tryParseXGITag addr with
                        |Some tag -> 
                            if tag.DataType = PLCHwModel.DataType.Bit 
                            then 
                                yield tag.ByteOffset
                            else 
                                yield! [tag.ByteOffset..tag.DataType.GetByteLength()]
                        |None ->
                            failwithlog $"tryParse{plcType} {addr} error"

                    | XGK ->    
                        match tryParseXGKTag addr with
                            |Some tag -> 
                                match tag.DataType with
                                | PLCHwModel.DataType.Bit -> yield tag.ByteOffset
                                | PLCHwModel.DataType.Word -> yield! [tag.ByteOffset..tag.ByteOffset + 1]   
                                | _-> failwithlog $"XGK Not supported plc {plcType} type"
                         
                            |None ->
                                failwithlog $"tryParse{plcType} {addr} error"

                    | _ -> failwithlog $"Not supported plc {plcType} type"
                ]
  

            let autoMemoryAllocationTags =
                system.TagManager.Storages.Values
                |> Seq.filter (fun f -> not <| (f :? TimerCounterBaseStruct))
                |> Seq.filter (fun f -> f.IsAutoGenerated)
                |> Array.ofSeq

            autoMemoryAllocationTags
            |> map (fun f -> f.Name)
            |> String.concat ", "
            |> logDebug "Auto Memory Allocation Tags: %s"

            // generate used memory byte indices
            autoMemoryAllocationTags
            |> Seq.collect (fun f -> f.Address |> getBytes)
            |> Seq.distinct
            |> Seq.sort
            |> List.ofSeq

        logDebug "Used byte indices: %A" usedByteIndices

        let prjParam: XgxProjectParams =
            let isAddRungComment = IsDebugVersion || isInUnitTest()
            let defaultProjectParams = if plcType = XGI then defaultXGIProjectParams else defaultXGKProjectParams       
            { defaultProjectParams with
                TargetType = plcType
                ProjectName = projName
                GlobalStorages = globalStorages
                ExistingLSISprj = existingLSISprj
                AppendDebugInfoToRungComment = isAddRungComment

                RungCounter = counterGenerator 0

                MemoryAllocatorSpec = AllocatorFunctions(createMemoryAllocator "M" (startMemory, 640 * 1024) usedByteIndices  plcType) // 640K M memory 영역
                TimerCounterGenerator = counterGeneratorWithExclusionList startTimer usedByteIndices
                CounterCounterGenerator = counterGeneratorWithExclusionList startCounter usedByteIndices
                AutoVariableCounter = counterGenerator 0

                POUs = [
                    yield pous.Where(fun f -> f.IsActive) |> getXgxPOUParams "Active" "Active"
                    yield pous.Where(fun f -> f.IsDevice) |> getXgxPOUParams "Devices" "Devices"
                    for p in pous.Where(fun f -> f.IsExternal) do
                        yield getXgxPOUParams (p.ToSystem().Name) (p.TaskName()) [ p ] ] }

        prjParam.GenerateXmlString()

    let exportXMLforLSPLC (plcType:PlatformTarget, system: DsSystem, path: string, existingLSISprj, startMemory, startTimer, startCounter) =
        assert(plcType.IsOneOf(XGI, XGK))
        use _ = logTraceEnabler()
        // RuntimeDS.Target <- plcType  // xxx 
        let globalStorage = new Storages()
        let localStorage = new Storages()
        let pous = CpuLoaderExt.LoadStatements(system, globalStorage, plcType)
        // Create a list to hold <C>ommented <S>tatement<S>
        let mutable css = []

        // Add commented statements from each CPU
        for cpu in pous do
            css <- css @ cpu.CommentedStatements() |> List.ofSeq

        let usedTagNames = getTotalTags(css.Select(fun s->s.Statement)) |> Seq.map(fun t->t.Name, t) |> dict
        globalStorage.Iter(fun tagKV-> 

            if not (usedTagNames.ContainsKey(tagKV.Key)) 
               && tagKV.Value.DataType = typedefof<bool>  //bool 타입만 지우기 가능 타이머 카운터 살림
               && TagKindExt.GetVariableTagKind(tagKV.Value).IsNone //VariableTag 살림
            then 
                globalStorage.Remove(tagKV.Key)|>ignore
            )

        let xml = generateXmlXGX plcType system globalStorage localStorage pous existingLSISprj startMemory  startTimer startCounter
        let crlfXml = xml.Replace("\r\n", "\n").Replace("\n", "\r\n")
        File.WriteAllText(path, crlfXml)


    let exportTextforDS () = ()

[<Extension>]
type ExportModuleExt =
    [<Extension>]
    static member ExportXMLforXGI(system: DsSystem, path: string, tempLSISxml:string, startMemory, startTimer, startCounter) =
        let existingLSISprj = if not(tempLSISxml.IsNullOrEmpty()) then Some(tempLSISxml) else None
        exportXMLforLSPLC (XGI, system, path, existingLSISprj, startMemory, startTimer, startCounter)

    [<Extension>]
    static member ExportXMLforXGK(system: DsSystem, path: string, tempLSISxml:string, startMemory, startTimer, startCounter) =
        let existingLSISprj = if not(tempLSISxml.IsNullOrEmpty()) then Some(tempLSISxml) else None
        exportXMLforLSPLC (XGK, system, path, existingLSISprj, startMemory, startTimer, startCounter)

