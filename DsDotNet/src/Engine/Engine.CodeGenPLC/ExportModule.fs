namespace Engine.CodeGenPLC

open System.IO
open System.Linq

open Dual.Common.Core.FS
open Dual.Common.Base.FS
open Dual.Common.Base.CS

open Engine.Core
open Engine.CodeGenCPU

open PLC.CodeGen.LS
open PLC.CodeGen.Common

[<AutoOpen>]
module ExportModule =
    /// 실제 구동용.  Generate XML file for XGI or XGK PLC.
    /// UnitTest 용은 generateXmlForTest 참고
    let private generateXmlXGX
        (plcType:PlatformTarget) (system: DsSystem)
        (globalStorages:Storages, localStorages:Storages)
        (pous: PouGen seq, maxPouSplit:int, existingLSISprj:string)
        (startMemory:int, startTimer:int, startCounter:int)
        (enableXmlComment:bool)
      : string =
        let projName = system.Name

        let getXgxPOUParamsFromCss (pouName: string) (css: CommentedStatement seq) =
            let pouParams: XgxPOUParams = {
                // POU name.  "DsLogic"
                POUName = pouName
                // POU ladder 최상단의 comment
                Comment = "DsLogic Automatically generate"
                LocalStorages = localStorages
                GlobalStorages = globalStorages
                CommentedStatements = css |> Seq.toList
            }
            pouParams

        let getXgxPOUParams (pouName: string) (pouGens: PouGen seq) =
            let css = pouGens.Collect(fun p -> p.CommentedStatements())
            getXgxPOUParamsFromCss pouName css

        let usedByteIndices =
            let getBytes addr =
                [
                    match plcType with
                    | XGI ->
                        match tryParseXGITag addr with
                        | Some tag ->
                            if tag.DataType = PLCHwModel.DataType.Bit then
                                yield tag.ByteOffset
                            else
                                yield! [tag.ByteOffset..tag.DataType.GetByteLength()]
                        | None ->
                            failwithlog $"tryParse{plcType} {addr} error"

                    | XGK ->
                        match tryParseXGKTag addr with
                            | Some tag ->
                                match tag.DataType with
                                | PLCHwModel.DataType.Bit -> yield tag.ByteOffset
                                | PLCHwModel.DataType.Word -> yield! [tag.ByteOffset..tag.ByteOffset + 1]
                                | _-> failwithlog $"XGK Not supported plc {plcType} type"

                            | None ->
                                failwithlog $"tryParse{plcType} {addr} error"

                    | _ -> failwithlog $"Not supported plc {plcType} type"
                ]


            let autoMemoryAllocationTags =
                system.TagManager.Storages.Values
                |> Seq.filter (fun f -> f.IsAutoGenerated)
                |> Seq.filter (fun f -> not <| (f :? TimerCounterBaseStruct))
                |> Array.ofSeq

#if DEBUG
            autoMemoryAllocationTags
            |> map (fun f -> f.Name)
            |> String.concat ", "
            |> logDebug "Auto Memory Allocation Tags: %s"
#endif

            // generate used memory byte indices
            autoMemoryAllocationTags
            |> Seq.collect (fun f -> f.Address |> getBytes)
            |> Seq.distinct
            |> Seq.sort
            |> List.ofSeq

#if DEBUG
        logDebug "Used byte indices: %A" usedByteIndices
#endif

        let prjParam: XgxProjectParams =
            let isAddRungComment = IsDebugVersion || isInUnitTest()

            // { Split POU's  (external 은 제외)
            let splitCommentedStatements (max:int) (cs:CommentedStatement seq) =
                cs |> chunkBySize max

            let activeCss, deviceCss =
                if maxPouSplit > 0 then
                    pous  .Where(fun p -> p.IsActive).Collect(fun p -> p.CommentedStatements()) |> splitCommentedStatements maxPouSplit
                    , pous.Where(fun p -> p.IsDevice).Collect(fun p -> p.CommentedStatements()) |> splitCommentedStatements maxPouSplit
                else
                    [], []
            // } Split POU's

            let defaultProjectParams = if plcType = XGI then defaultXGIProjectParams else defaultXGKProjectParams

            {
                defaultProjectParams with
                    TargetType = plcType
                    ProjectName = projName
                    GlobalStorages = globalStorages
                    ExistingLSISprj = existingLSISprj
                    AppendDebugInfoToRungComment = isAddRungComment
                    EnableXmlComment = enableXmlComment

                    RungCounter = counterGenerator 0
                    //XGI 초기값 때문에 M 사용 XGK는 R 사용
                    MemoryAllocatorSpec = AllocatorFunctions(createMemoryAllocator (if plcType = XGI then "M" else "R") (startMemory, 640 * 1024) usedByteIndices  plcType) // 640K M memory 영역
                    TimerCounterGenerator = counterGeneratorWithExclusionList startTimer usedByteIndices
                    CounterCounterGenerator = counterGeneratorWithExclusionList startCounter usedByteIndices
                    AutoVariableCounter = counterGenerator 0

                    POUs = [
                        if maxPouSplit > 0 then
                            for (n, a) in activeCss |> Seq.indexed do
                                let name = $"Active{n}"
                                yield getXgxPOUParamsFromCss name a
                            for (n, d) in deviceCss |> Seq.indexed do
                                let name = $"Devices{n}"
                                yield getXgxPOUParamsFromCss name d
                        else
                            (* No split *)
                            yield pous.Where(fun f -> f.IsActive) |> getXgxPOUParams "Active"
                            yield pous.Where(fun f -> f.IsDevice) |> getXgxPOUParams "Devices"

                        for p in pous.Where(fun f -> f.IsExternal) do
                            yield getXgxPOUParams (p.ToSystem().Name) [ p ]
                    ]
            }

        prjParam.GenerateXmlString()

    /// LS PLC (XGI or XGK) 생성을 위한 파라미터.  API 를 통해 생성 패러미터 전달시 사용. LsPLC.ExportXML 및  exportXMLforLSPLC 함수에서 사용
    type XgxGenerationParameters =
        {
            PlatformTarget: PlatformTarget
            mutable System: DsSystem
            mutable OutputXmlPath: string
            mutable ExistingLSISprj: string
            mutable StartTimer: int
            mutable StartCounter: int
            mutable EnableXmlComment: bool
            mutable MaxPouSplit: int
        }
        static member Default() = {
            PlatformTarget = XGI
            System = getNull<DsSystem>()
            OutputXmlPath = ""
            ExistingLSISprj = ""
            StartTimer = 0
            StartCounter = 0
            EnableXmlComment = true
            MaxPouSplit = 0     // 사용한다면 2000 정도 권장
        }

        static member Create(platformTarget: PlatformTarget, system: DsSystem, outputXmlPath: string) =
            {
                XgxGenerationParameters.Default() with
                    PlatformTarget = platformTarget
                    System = system
                    OutputXmlPath = outputXmlPath
            }


    let exportXMLforLSPLC (xgxGenParams:XgxGenerationParameters) =
        let _, millisecond =
            duration (fun () ->
                let {
                    PlatformTarget = platformTarget
                    System = system
                    OutputXmlPath = path
                    ExistingLSISprj = existingLSISprj
                    StartTimer = startTimer
                    StartCounter = startCounter
                    EnableXmlComment = enableXmlComment
                    MaxPouSplit = maxPouSplit
                } = xgxGenParams

                if !! platformTarget.IsOneOf(XGI, XGK) then
                    failwithf $"Not supported plc {platformTarget} type"

                //use _ = DcLogger.CreateTraceEnabler()
                let globalStorage = new Storages()
                let localStorage = new Storages()
                let pous = system.GeneratePOUs(globalStorage, platformTarget).ToArray() //startMemory 구하기 위해 ToArray로 미리 처리

                let startMemory = DsAddressModule.getCurrentMemoryIndex()/8+1  // bit를 바이트 단위로 나누고 다음 바이트 시작 주소로 설정

                // Create a list to hold <C>ommented <S>tatement<S>
                let css = [|
                    // Add commented statements from each CPU
                    for cpu in pous do
                        yield! cpu.CommentedStatements()
                |]

                let usedTagNames = getTotalTags(css.Select(fun s->s.Statement)) |> Seq.map(fun t->t.Name, t) |> dict
                let globalStorageCc = new Storages(globalStorage)
                globalStorageCc.Iter(fun tagKV->

                    if not (usedTagNames.ContainsKey(tagKV.Key))
                       && tagKV.Value.DataType = typedefof<bool>  //bool 타입만 지우기 가능 타이머 카운터 살림
                       && TagKindExt.TryGetVariableTagKind(tagKV.Value).IsNone //VariableTag 살림
                    then
                        globalStorage.Remove(tagKV.Key)|>ignore
                    )

                let xml, millisecond = duration (fun () ->
                    generateXmlXGX platformTarget system (globalStorage, localStorage) (pous, maxPouSplit, existingLSISprj) (startMemory, startTimer, startCounter) enableXmlComment )

                forceTrace $"\tgenerateXmlXGX: elapsed {millisecond} ms"



                let crlfXml = xml.Replace("\r\n", "\n").Replace("\n", "\r\n")
                File.WriteAllText(path, crlfXml)
            )
        forceTrace $"exportXMLforLSPLC : elapsed {millisecond} ms"




    let exportTextforDS () = ()


type LsPLC =
    static member ExportXML(xgxGenParams:XgxGenerationParameters) = exportXMLforLSPLC xgxGenParams



