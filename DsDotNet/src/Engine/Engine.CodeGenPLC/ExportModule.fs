namespace Engine.CodeGenPLC

open System.IO
open System.Linq
open System.Runtime.CompilerServices
open Engine.Core
open Dual.Common.Core.FS
open PLC.CodeGen.LS
open PLC.CodeGen.Common
open Engine.CodeGenCPU
open Dual.Common.Base.FS
open Dual.Common.Base.CS

[<AutoOpen>]
module ExportModule =
    /// 실제 구동용.  Generate XML file for XGI or XGK PLC.
    /// UnitTest 용은 generateXmlForTest 참고
    let private generateXmlXGX
        (plcType:PlatformTarget) (system: DsSystem)
        (globalStorages:Storages, localStorages:Storages)
        (pous: PouGen seq, maxPouSplit:int option, existingLSISprj:string option)
        (startMemory:int, startTimer:int, startCounter:int)
        (enableXmlComment:bool)
      : string =
        let projName = system.Name

        let getXgxPOUParamsFromCss (pouName: string) (css: CommentedStatement seq) =
            let pouParams: XgxPOUParams = {
                // POU name.  "DsLogic"
                POUName = pouName
                // POU ladder 최상단의 comment
                Comment = "DsLogic Automatically generate"
                LocalStorages = localStorages
                GlobalStorages = globalStorages
                CommentedStatements = css |> Seq.toList
            }
            pouParams

        let getXgxPOUParams (pouName: string) (pouGens: PouGen seq) =
            let css = pouGens.Collect(fun p -> p.CommentedStatements())
            getXgxPOUParamsFromCss pouName css

        let usedByteIndices =
            let getBytes addr =
                [
                    match plcType with
                    | XGI ->
                        match tryParseXGITag addr with
                        | Some tag ->
                            if tag.DataType = PLCHwModel.DataType.Bit then
                                yield tag.ByteOffset
                            else
                                yield! [tag.ByteOffset..tag.DataType.GetByteLength()]
                        | None ->
                            failwithlog $"tryParse{plcType} {addr} error"

                    | XGK ->
                        match tryParseXGKTag addr with
                            | Some tag ->
                                match tag.DataType with
                                | PLCHwModel.DataType.Bit -> yield tag.ByteOffset
                                | PLCHwModel.DataType.Word -> yield! [tag.ByteOffset..tag.ByteOffset + 1]
                                | _-> failwithlog $"XGK Not supported plc {plcType} type"

                            | None ->
                                failwithlog $"tryParse{plcType} {addr} error"

                    | _ -> failwithlog $"Not supported plc {plcType} type"
                ]


            let autoMemoryAllocationTags =
                system.TagManager.Storages.Values
                |> Seq.filter (fun f -> f.IsAutoGenerated)
                |> Seq.filter (fun f -> not <| (f :? TimerCounterBaseStruct))
                |> Array.ofSeq

#if DEBUG
            autoMemoryAllocationTags
            |> map (fun f -> f.Name)
            |> String.concat ", "
            |> logDebug "Auto Memory Allocation Tags: %s"
#endif

            // generate used memory byte indices
            autoMemoryAllocationTags
            |> Seq.collect (fun f -> f.Address |> getBytes)
            |> Seq.distinct
            |> Seq.sort
            |> List.ofSeq

#if DEBUG
        logDebug "Used byte indices: %A" usedByteIndices
#endif

        let prjParam: XgxProjectParams =
            let isAddRungComment = IsDebugVersion || isInUnitTest()

            // { Split POU's  (external 은 제외)
            let splitCommentedStatements (max:int) (cs:CommentedStatement seq) =
                cs |> chunkBySize max

            let activeCss, deviceCss =
                match maxPouSplit with
                | Some max ->
                    pous  .Where(fun p -> p.IsActive).Collect(fun p -> p.CommentedStatements()) |> splitCommentedStatements max
                    , pous.Where(fun p -> p.IsDevice).Collect(fun p -> p.CommentedStatements()) |> splitCommentedStatements max
                | None ->
                    [], []
            // } Split POU's

            let defaultProjectParams = if plcType = XGI then defaultXGIProjectParams else defaultXGKProjectParams

            {
                defaultProjectParams with
                    TargetType = plcType
                    ProjectName = projName
                    GlobalStorages = globalStorages
                    ExistingLSISprj = existingLSISprj
                    AppendDebugInfoToRungComment = isAddRungComment
                    EnableXmlComment = enableXmlComment

                    RungCounter = counterGenerator 0
                    //XGI 초기값 때문에 M 사용 XGK는 R 사용
                    MemoryAllocatorSpec = AllocatorFunctions(createMemoryAllocator (if plcType = XGI then "M" else "R") (startMemory, 640 * 1024) usedByteIndices  plcType) // 640K M memory 영역
                    TimerCounterGenerator = counterGeneratorWithExclusionList startTimer usedByteIndices
                    CounterCounterGenerator = counterGeneratorWithExclusionList startCounter usedByteIndices
                    AutoVariableCounter = counterGenerator 0

                    POUs = [
                        match maxPouSplit with
                        | Some _ ->
                            for (n, a) in activeCss |> Seq.indexed do
                                let name = $"Active{n}"
                                yield getXgxPOUParamsFromCss name a
                            for (n, d) in deviceCss |> Seq.indexed do
                                let name = $"Devices{n}"
                                yield getXgxPOUParamsFromCss name d
                        | None ->
                            (* No split *)
                            yield pous.Where(fun f -> f.IsActive) |> getXgxPOUParams "Active"
                            yield pous.Where(fun f -> f.IsDevice) |> getXgxPOUParams "Devices"

                        for p in pous.Where(fun f -> f.IsExternal) do
                            yield getXgxPOUParams (p.ToSystem().Name) [ p ]
                    ]
            }

        prjParam.GenerateXmlString()

    let exportXMLforLSPLC (platformTarget:PlatformTarget, system: DsSystem, path: string, existingLSISprj, startTimer, startCounter, enableXmlComment:bool, maxPouSplit:int option) =
        let _, millisecond = duration (fun () ->
            //use _ = DcLogger.CreateTraceEnabler()
            let globalStorage = new Storages()
            let localStorage = new Storages()
            let pous = system.GeneratePOUs(globalStorage, platformTarget).ToArray() //startMemory 구하기 위해 ToArray로 미리 처리

            let startMemory = DsAddressModule.getCurrentMemoryIndex()/8+1  // bit를 바이트 단위로 나누고 다음 바이트 시작 주소로 설정

            // Create a list to hold <C>ommented <S>tatement<S>
            let css = [|
                // Add commented statements from each CPU
                for cpu in pous do
                    yield! cpu.CommentedStatements()
            |]

            let usedTagNames = getTotalTags(css.Select(fun s->s.Statement)) |> Seq.map(fun t->t.Name, t) |> dict
            let globalStorageCc = new Storages(globalStorage)
            globalStorageCc.Iter(fun tagKV->

                if not (usedTagNames.ContainsKey(tagKV.Key))
                   && tagKV.Value.DataType = typedefof<bool>  //bool 타입만 지우기 가능 타이머 카운터 살림
                   && TagKindExt.TryGetVariableTagKind(tagKV.Value).IsNone //VariableTag 살림
                then
                    globalStorage.Remove(tagKV.Key)|>ignore
                )

            let xml, millisecond = duration (fun () ->
                generateXmlXGX platformTarget system (globalStorage, localStorage) (pous, maxPouSplit, existingLSISprj) (startMemory, startTimer, startCounter) enableXmlComment )

            forceTrace $"\tgenerateXmlXGX: elapsed {millisecond} ms"



            let crlfXml = xml.Replace("\r\n", "\n").Replace("\n", "\r\n")
            File.WriteAllText(path, crlfXml)
        )
        forceTrace $"exportXMLforLSPLC : elapsed {millisecond} ms"




    let exportTextforDS () = ()

[<Extension>]
type ExportModuleExt =
    [<Extension>]
    static member ExportXMLforXGI(system: DsSystem, path: string, tempLSISxml:string, startTimer, startCounter, enableXmlComment, maxPouSplit) =
        let existingLSISprj = if not(tempLSISxml.IsNullOrEmpty()) then Some(tempLSISxml) else None
        exportXMLforLSPLC (XGI, system, path, existingLSISprj, startTimer, startCounter, enableXmlComment, maxPouSplit)

    [<Extension>]
    static member ExportXMLforXGK(system: DsSystem, path: string, tempLSISxml:string, startTimer, startCounter, enableXmlComment, maxPouSplit) =
        let existingLSISprj = if not(tempLSISxml.IsNullOrEmpty()) then Some(tempLSISxml) else None
        exportXMLforLSPLC (XGK, system, path, existingLSISprj,  startTimer, startCounter, enableXmlComment, maxPouSplit)

