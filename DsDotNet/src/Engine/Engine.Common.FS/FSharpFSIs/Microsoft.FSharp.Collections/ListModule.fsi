/// Basic operations on lists.
[<CompilationRepresentation(enum<CompilationRepresentationFlags> (4))>]
[<RequireQualifiedAccess>]
module Microsoft.FSharp.Collections.List

/// Returns a new list that contains the elements of the first list followed by elements of the second.
/// list1: The first input list.
/// list2: The second input list.
val append : list1:'T list -> list2:'T list -> 'T list
/// Returns the average of the elements in the list.
/// list: The input list.
val inline average : list: ^T list ->  ^T when ^T : (static member ( + ) :  ^T *  ^T ->  ^T) and ^T : (static member DivideByInt :  ^T * int ->  ^T) and ^T : (static member Zero :  ^T)
/// Returns the average of the elements generated by applying the function to each element of the list.
/// projection: The function to transform the list elements into the type to be averaged.
/// list: The input list.
val inline averageBy : projection:('T ->  ^U) -> list:'T list ->  ^U when ^U : (static member ( + ) :  ^U *  ^U ->  ^U) and ^U : (static member DivideByInt :  ^U * int ->  ^U) and ^U : (static member Zero :  ^U)
/// Applies the given function to each element of the list. Returns the list comprised of the results x for each element where the function returns Some(x)
/// chooser: The function to generate options from the elements.
/// list: The input list.
val choose : chooser:('T -> 'U option) -> list:'T list -> 'U list
/// Divides the input list into chunks of size at most chunkSize.
/// chunkSize: The maximum size of each chunk.
/// list: The input list.
val chunkBySize : chunkSize:int -> list:'T list -> 'T list list
/// For each element of the list, applies the given function. Concatenates all the results and return the combined list.
/// mapping: The function to transform each input element into a sublist to be concatenated.
/// list: The input list.
val collect : mapping:('T -> 'U list) -> list:'T list -> 'U list
/// Compares two lists using the given comparison function, element by element.  Returns the first non-zero result from the comparison function. If the end of a list is reached it returns a -1 if the first list is shorter and a 1 if the second list is shorter.
/// comparer: A function that takes an element from each list and returns an int.  If it evaluates to a non-zero value iteration is stopped and that value is returned.
/// list1: The first input list.
/// list2: The second input list.
val inline compareWith : comparer:('T -> 'T -> int) -> list1:'T list -> list2:'T list -> int
/// Returns a new list that contains the elements of each the lists in order.
/// lists: The input sequence of lists.
val concat : lists:seq<'T list> -> 'T list
/// Tests if the list contains the specified element.
/// value: The value to locate in the input list.
/// source: The input list.
val inline contains : value:'T -> source:'T list -> bool when 'T : equality
/// Returns a list that contains no duplicate entries according to generic hash and equality comparisons on the entries.  If an element occurs multiple times in the list then the later occurrences are discarded.
/// list: The input list.
val distinct : list:'T list -> 'T list when 'T : equality
/// Returns a list that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function.  If an element occurs multiple times in the list then the later occurrences are discarded.
/// projection: A function transforming the list items into comparable keys.
/// list: The input list.
val distinctBy : projection:('T -> 'Key) -> list:'T list -> 'T list when 'Key : equality
/// Applies a key-generating function to each element of a list and returns a list yielding unique keys and their number of occurrences in the original list.
/// projection: A function transforming each item of the input list into a key to be compared against the others.
/// list: The input list.
val countBy : projection:('T -> 'Key) -> list:'T list -> ('Key * int) list when 'Key : equality
/// Splits the input list into at most count chunks.
/// count: The maximum number of chunks.
/// list: The input list.
val splitInto : count:int -> list:'T list -> 'T list list
/// Returns an empty list of the given type.
val empty : 'T list
/// Returns a new list with the distinct elements of the input list which do not appear in the itemsToExclude sequence, using generic hash and equality comparisons to compare values.
/// itemsToExclude: A sequence whose elements that also occur in the input list will cause those elements to be removed from the result.
/// list: A list whose elements that are not also in itemsToExclude will be returned.
val except : itemsToExclude:seq<'T> -> list:'T list -> 'T list when 'T : equality
/// Returns the only element of the list.
/// list: The input list.
val exactlyOne : list:'T list -> 'T
/// Tests if any element of the list satisfies the given predicate.
/// predicate: The function to test the input elements.
/// list: The input list.
val exists : predicate:('T -> bool) -> list:'T list -> bool
/// Tests if any pair of corresponding elements of the lists satisfies the given predicate.
/// predicate: The function to test the input elements.
/// list1: The first input list.
/// list2: The second input list.
val exists2 : predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool
/// Returns the first element for which the given function returns true.  Raises KeyNotFoundException if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val find : predicate:('T -> bool) -> list:'T list -> 'T
/// Returns the last element for which the given function returns true.  Raises KeyNotFoundException if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val findBack : predicate:('T -> bool) -> list:'T list -> 'T
/// Returns the index of the first element in the list that satisfies the given predicate.  Raises KeyNotFoundException if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val findIndex : predicate:('T -> bool) -> list:'T list -> int
/// Returns the index of the last element in the list that satisfies the given predicate.  Raises KeyNotFoundException if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val findIndexBack : predicate:('T -> bool) -> list:'T list -> int
/// Returns a new collection containing only the elements of the collection for which the given predicate returns "true"
/// predicate: The function to test the input elements.
/// list: The input list.
val filter : predicate:('T -> bool) -> list:'T list -> 'T list
/// Applies a function to each element of the collection, threading an accumulator argument through the computation. Take the second argument, and apply the function to it and the first element of the list. Then feed this result into the function along with the second element and so on. Return the final result.  If the input function is f and the elements are i0...iN then computes f (... (f s i0) i1 ...) iN.
/// folder: The function to update the state given the input elements.
/// state: The initial state.
/// list: The input list.
val fold : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State
/// Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes.  If the input function is f and the elements are i0...iN and j0...jN then computes f (... (f s i0 j0)...) iN jN.
/// folder: The function to update the state given the input elements.
/// state: The initial state.
/// list1: The first input list.
/// list2: The second input list.
val fold2 : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> list1:'T1 list -> list2:'T2 list -> 'State
/// Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN then computes f i0 (...(f iN s)).
/// folder: The function to update the state given the input elements.
/// list: The input list.
/// state: The initial state.
val foldBack : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State
/// Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes.  If the input function is f and the elements are i0...iN and j0...jN then computes f i0 j0 (...(f iN jN s)).
/// folder: The function to update the state given the input elements.
/// list1: The first input list.
/// list2: The second input list.
/// state: The initial state.
val foldBack2 : folder:('T1 -> 'T2 -> 'State -> 'State) -> list1:'T1 list -> list2:'T2 list -> state:'State -> 'State
/// Tests if all elements of the collection satisfy the given predicate.
/// predicate: The function to test the input elements.
/// list: The input list.
val forall : predicate:('T -> bool) -> list:'T list -> bool
/// Tests if all corresponding elements of the collection satisfy the given predicate pairwise.
/// predicate: The function to test the input elements.
/// list1: The first input list.
/// list2: The second input list.
val forall2 : predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool
/// Applies a key-generating function to each element of a list and yields a list of unique keys. Each unique key contains a list of all elements that match to this key.
/// projection: A function that transforms an element of the list into a comparable key.
/// list: The input list.
val groupBy : projection:('T -> 'Key) -> list:'T list -> ('Key * 'T list) list when 'Key : equality
/// Returns the first element of the list.
/// list: The input list.
val head : list:'T list -> 'T
/// Returns a new list whose elements are the corresponding elements of the input list paired with the index (from 0) of each element.
/// list: The input list.
val indexed : list:'T list -> (int * 'T) list
/// Creates a list by calling the given generator on each index.
/// length: The length of the list to generate.
/// initializer: The function to generate an element from an index.
val init : length:int -> initializer:(int -> 'T) -> 'T list
/// Returns true if the list contains no elements, false otherwise.
/// list: The input list.
val isEmpty : list:'T list -> bool
/// Indexes into the list. The first element has index 0.
/// index: The index to retrieve.
/// list: The input list.
val item : index:int -> list:'T list -> 'T
/// Applies the given function to each element of the collection.
/// action: The function to apply to elements from the input list.
/// list: The input list.
val iter : action:('T -> unit) -> list:'T list -> unit
/// Applies the given function to two collections simultaneously. The collections must have identical size.
/// action: The function to apply to pairs of elements from the input lists.
/// list1: The first input list.
/// list2: The second input list.
val iter2 : action:('T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit
/// Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.
/// action: The function to apply to the elements of the list along with their index.
/// list: The input list.
val iteri : action:(int -> 'T -> unit) -> list:'T list -> unit
/// Applies the given function to two collections simultaneously. The collections must have identical size. The integer passed to the function indicates the index of element.
/// action: The function to apply to a pair of elements from the input lists along with their index.
/// list1: The first input list.
/// list2: The second input list.
val iteri2 : action:(int -> 'T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit
/// Returns the last element of the list.
/// list: The input list.
val last : list:'T list -> 'T
/// Returns the length of the list.
/// list: The input list.
val length : list:'T list -> int
/// Returns the last element of the list.  Return None if no such element exists.
/// list: The input list.
val tryLast : list:'T list -> 'T option
/// Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection.
/// mapping: The function to transform elements from the input list.
/// list: The input list.
val map : mapping:('T -> 'U) -> list:'T list -> 'U list
/// Builds a new collection whose elements are the results of applying the given function to the corresponding elements of the two collections pairwise.
/// mapping: The function to transform pairs of elements from the input lists.
/// list1: The first input list.
/// list2: The second input list.
val map2 : mapping:('T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list
/// Builds a new collection whose elements are the results of applying the given function to the corresponding elements of the three collections simultaneously.
/// mapping: The function to transform triples of elements from the input lists.
/// list1: The first input list.
/// list2: The second input list.
/// list3: The third input list.
val map3 : mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> 'U list
/// Combines map and fold. Builds a new list whose elements are the results of applying the given function to each of the elements of the input list. The function is also used to accumulate a final value.
/// mapping: The function to transform elements from the input list and accumulate the final value.
/// state: The initial state.
/// list: The input list.
val mapFold : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> list:'T list -> 'Result list * 'State
/// Combines map and foldBack. Builds a new list whose elements are the results of applying the given function to each of the elements of the input list. The function is also used to accumulate a final value.
/// mapping: The function to transform elements from the input list and accumulate the final value.
/// list: The input list.
/// state: The initial state.
val mapFoldBack : mapping:('T -> 'State -> 'Result * 'State) -> list:'T list -> state:'State -> 'Result list * 'State
/// Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.
/// mapping: The function to transform elements and their indices.
/// list: The input list.
val mapi : mapping:(int -> 'T -> 'U) -> list:'T list -> 'U list
/// Like mapi, but mapping corresponding elements from two lists of equal length.
/// mapping: The function to transform pairs of elements from the two lists and their index.
/// list1: The first input list.
/// list2: The second input list.
val mapi2 : mapping:(int -> 'T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list
/// Return the greatest of all elements of the list, compared via Operators.max.
/// list: The input list.
val inline max : list:'T list -> 'T when 'T : comparison
/// Returns the greatest of all elements of the list, compared via Operators.max on the function result.
/// projection: The function to transform the list elements into the type to be compared.
/// list: The input list.
val inline maxBy : projection:('T -> 'U) -> list:'T list -> 'T when 'U : comparison
/// Returns the lowest of all elements of the list, compared via Operators.min.
/// list: The input list.
val inline min : list:'T list -> 'T when 'T : comparison
/// Returns the lowest of all elements of the list, compared via Operators.min on the function result
/// projection: The function to transform list elements into the type to be compared.
/// list: The input list.
val inline minBy : projection:('T -> 'U) -> list:'T list -> 'T when 'U : comparison
/// Indexes into the list. The first element has index 0.
/// list: The input list.
/// index: The index to retrieve.
val nth : list:'T list -> index:int -> 'T
/// Builds a list from the given array.
/// array: The input array.
val ofArray : array:'T [] -> 'T list
/// Builds a new list from the given enumerable object.
/// source: The input sequence.
val ofSeq : source:seq<'T> -> 'T list
/// Returns a list of each element in the input list and its predecessor, with the exception of the first element which is only returned as the predecessor of the second element.
/// list: The input list.
val pairwise : list:'T list -> ('T * 'T) list
/// Splits the collection into two collections, containing the elements for which the given predicate returns true and false respectively. Element order is preserved in both of the created lists.
/// predicate: The function to test the input elements.
/// list: The input list.
val partition : predicate:('T -> bool) -> list:'T list -> 'T list * 'T list
/// Applies the given function to successive elements, returning the first result where function returns Some(x) for some x. If no such element exists then raise System.Collections.Generic.KeyNotFoundException
/// chooser: The function to generate options from the elements.
/// list: The input list.
val pick : chooser:('T -> 'U option) -> list:'T list -> 'U
/// Returns a list with all elements permuted according to the specified permutation.
/// indexMap: The function to map input indices to output indices.
/// list: The input list.
val permute : indexMap:(int -> int) -> list:'T list -> 'T list
/// Apply a function to each element of the collection, threading an accumulator argument through the computation. Apply the function to the first two elements of the list.  Then feed this result into the function along with the third element and so on. Return the final result. If the input function is f and the elements are i0...iN then computes f (... (f i0 i1) i2 ...) iN.
/// reduction: The function to reduce two list elements to a single element.
/// list: The input list.
val reduce : reduction:('T -> 'T -> 'T) -> list:'T list -> 'T
/// Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN then computes f i0 (...(f iN-1 iN)).
/// reduction: A function that takes in the next-to-last element of the list and the current accumulated result to produce the next accumulated result.
/// list: The input list.
val reduceBack : reduction:('T -> 'T -> 'T) -> list:'T list -> 'T
/// Creates a list by replicating the given initial value.
/// count: The number of elements to replicate.
/// initial: The value to replicate
val replicate : count:int -> initial:'T -> 'T list
/// Returns a new list with the elements in reverse order.
/// list: The input list.
val rev : list:'T list -> 'T list
/// Applies a function to each element of the collection, threading an accumulator argument through the computation. Take the second argument, and apply the function to it and the first element of the list. Then feed this result into the function along with the second element and so on. Returns the list of intermediate results and the final result.
/// folder: The function to update the state given the input elements.
/// state: The initial state.
/// list: The input list.
val scan : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State list
/// Like foldBack, but returns both the intermediary and final results
/// folder: The function to update the state given the input elements.
/// list: The input list.
/// state: The initial state.
val scanBack : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State list
/// Returns a list that contains one item only.
/// value: The input item.
val inline singleton : value:'T -> 'T list
/// Returns the list after removing the first N elements.
/// count: The number of elements to skip.
/// list: The input list.
val skip : count:int -> list:'T list -> 'T list
/// Bypasses elements in a list while the given predicate returns true, and then returns the remaining elements of the list.
/// predicate: A function that evaluates an element of the list to a boolean value.
/// list: The input list.
val skipWhile : predicate:('T -> bool) -> list:'T list -> 'T list
/// Sorts the given list using the given comparison function.
/// comparer: The function to compare the list elements.
/// list: The input list.
val sortWith : comparer:('T -> 'T -> int) -> list:'T list -> 'T list
/// Sorts the given list using keys given by the given projection. Keys are compared using Operators.compare.
/// projection: The function to transform the list elements into the type to be compared.
/// list: The input list.
val sortBy : projection:('T -> 'Key) -> list:'T list -> 'T list when 'Key : comparison
/// Sorts the given list using Operators.compare.
/// list: The input list.
val sort : list:'T list -> 'T list when 'T : comparison
/// Splits a list into two lists, at the given index.
/// index: The index at which the list is split.
/// list: The input list.
val splitAt : index:int -> list:'T list -> 'T list * 'T list
/// Sorts the given list in descending order using keys given by the given projection. Keys are compared using Operators.compare.
/// projection: The function to transform the list elements into the type to be compared.
/// list: The input list.
val inline sortByDescending : projection:('T -> 'Key) -> list:'T list -> 'T list when 'Key : comparison
/// Sorts the given list in descending order using Operators.compare.
/// list: The input list.
val inline sortDescending : list:'T list -> 'T list when 'T : comparison
/// Returns the sum of the elements in the list.
/// list: The input list.
val inline sum : list: ^T list ->  ^T when ^T : (static member ( + ) :  ^T *  ^T ->  ^T) and ^T : (static member Zero :  ^T)
/// Returns the sum of the results generated by applying the function to each element of the list.
/// projection: The function to transform the list elements into the type to be summed.
/// list: The input list.
val inline sumBy : projection:('T ->  ^U) -> list:'T list ->  ^U when ^U : (static member ( + ) :  ^U *  ^U ->  ^U) and ^U : (static member Zero :  ^U)
/// Returns the list after removing the first element.
/// list: The input list.
val tail : list:'T list -> 'T list
/// Returns the first N elements of the list.
/// count: The number of items to take.
/// list: The input list.
val take : count:int -> list:'T list -> 'T list
/// Returns a list that contains all elements of the original list while the given predicate returns true, and then returns no further elements.
/// predicate: A function that evaluates to false when no more items should be returned.
/// list: The input list.
val takeWhile : predicate:('T -> bool) -> list:'T list -> 'T list
/// Builds an array from the given list.
/// list: The input list.
val toArray : list:'T list -> 'T []
/// Views the given list as a sequence.
/// list: The input list.
val toSeq : list:'T list -> seq<'T>
/// Returns the first element of the list, or None if the list is empty.
/// list: The input list.
val tryHead : list:'T list -> 'T option
/// Returns at most N elements in a new list.
/// count: The maximum number of items to return.
/// array: The input list.
val truncate : count:int -> list:'T list -> 'T list
/// Applies the given function to successive elements, returning Some(x) the first result where function returns Some(x) for some x. If no such element exists then return None.
/// chooser: The function to generate options from the elements.
/// list: The input list.
val tryPick : chooser:('T -> 'U option) -> list:'T list -> 'U option
/// Returns the first element for which the given function returns true..  Return None if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val tryFind : predicate:('T -> bool) -> list:'T list -> 'T option
/// Returns the last element for which the given function returns true..  Return None if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val tryFindBack : predicate:('T -> bool) -> list:'T list -> 'T option
/// Returns the index of the first element in the list that satisfies the given predicate.  Return None if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val tryFindIndex : predicate:('T -> bool) -> list:'T list -> int option
/// Tries to find the nth element in the list.  Returns None if index is negative or the list does not contain enough elements.
/// index: The index to retrieve.
/// list: The input list.
val tryItem : index:int -> list:'T list -> 'T option
/// Returns the index of the last element in the list that satisfies the given predicate.  Return None if no such element exists.
/// predicate: The function to test the input elements.
/// list: The input list.
val tryFindIndexBack : predicate:('T -> bool) -> list:'T list -> int option
/// Returns a list that contains the elements generated by the given computation.  The given initial state argument is passed to the element generator.
/// generator: A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.
/// state: The initial state value.
val unfold : generator:('State -> ('T * 'State) option) -> state:'State -> 'T list
/// Splits a list of pairs into two lists.
/// list: The input list.
val unzip : list:('T1 * 'T2) list -> 'T1 list * 'T2 list
/// Splits a list of triples into three lists.
/// list: The input list.
val unzip3 : list:('T1 * 'T2 * 'T3) list -> 'T1 list * 'T2 list * 'T3 list
/// Returns a new list containing only the elements of the list for which the given predicate returns "true"
/// predicate: The function to test the input elements.
/// list: The input list.
val where : predicate:('T -> bool) -> list:'T list -> 'T list
/// Returns a list of sliding windows containing elements drawn from the input list. Each window is returned as a fresh list.
/// windowSize: The number of elements in each window.
/// list: The input list.
val windowed : windowSize:int -> list:'T list -> 'T list list
/// Combines the two lists into a list of pairs. The two lists must have equal lengths.
/// list1: The first input list.
/// list2: The second input list.
val zip : list1:'T1 list -> list2:'T2 list -> ('T1 * 'T2) list
/// Combines the three lists into a list of triples. The lists must have equal lengths.
/// list1: The first input list.
/// list2: The second input list.
/// list3: The third input list.
val zip3 : list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> ('T1 * 'T2 * 'T3) list
