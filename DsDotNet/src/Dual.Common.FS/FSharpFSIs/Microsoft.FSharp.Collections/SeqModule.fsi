/// Basic operations on IEnumerables.
[<RequireQualifiedAccess>]
[<CompilationRepresentation(enum<CompilationRepresentationFlags> (4))>]
module Microsoft.FSharp.Collections.Seq

/// Wraps the two given enumerations as a single concatenated enumeration.
/// source1: The first sequence.
/// source2: The second sequence.
val append : source1:seq<'T> -> source2:seq<'T> -> seq<'T>
/// Returns the average of the elements in the sequence.
/// source: The input sequence.
val inline average : source:seq< ^T> ->  ^T when ^T : (static member ( + ) :  ^T *  ^T ->  ^T) and ^T : (static member DivideByInt :  ^T * int ->  ^T) and ^T : (static member Zero :  ^T)
/// Returns the average of the results generated by applying the function to each element of the sequence.
/// projection: A function applied to transform each element of the sequence.
/// source: The input sequence.
val inline averageBy : projection:('T ->  ^U) -> source:seq<'T> ->  ^U when ^U : (static member ( + ) :  ^U *  ^U ->  ^U) and ^U : (static member DivideByInt :  ^U * int ->  ^U) and ^U : (static member Zero :  ^U)
/// Returns a sequence that corresponds to a cached version of the input sequence.  This result sequence will have the same elements as the input sequence. The result can be enumerated multiple times. The input sequence will be enumerated at most once and only as far as is necessary. Caching a sequence is typically useful when repeatedly evaluating items in the original sequence is computationally expensive or if iterating the sequence causes side-effects that the user does not want to be repeated multiple times.  Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator values may be used simultaneously from different threads (accesses to the internal lookaside table are thread safe). Each individual IEnumerator is not typically thread safe and should not be accessed concurrently.
/// source: The input sequence.
val cache : source:seq<'T> -> seq<'T>
/// Wraps a loosely-typed System.Collections sequence as a typed sequence.
/// source: The input sequence.
val cast : source:System.Collections.IEnumerable -> seq<'T>
/// Applies the given function to each element of the list. Return the list comprised of the results "x" for each element where the function returns Some(x).
/// chooser: A function to transform items of type T into options of type U.
/// source: The input sequence of type T.
val choose : chooser:('T -> 'U option) -> source:seq<'T> -> seq<'U>
/// Divides the input sequence into chunks of size at most chunkSize.
/// chunkSize: The maximum size of each chunk.
/// source: The input sequence.
val chunkBySize : chunkSize:int -> source:seq<'T> -> seq<'T []>
/// Applies the given function to each element of the sequence and concatenates all the results.
/// mapping: A function to transform elements of the input sequence into the sequences that will then be concatenated.
/// source: The input sequence.
val collect : mapping:('T -> 'Collection) -> source:seq<'T> -> seq<'U> when 'Collection :> seq<'U>
/// Compares two sequences using the given comparison function, element by element.  Returns the first non-zero result from the comparison function. If the end of a sequence is reached it returns a -1 if the first sequence is shorter and a 1 if the second sequence is shorter.
/// comparer: A function that takes an element from each sequence and returns an int.  If it evaluates to a non-zero value iteration is stopped and that value is returned.
/// source1: The first input sequence.
/// source2: The second input sequence.
val compareWith : comparer:('T -> 'T -> int) -> source1:seq<'T> -> source2:seq<'T> -> int
/// Combines the given enumeration-of-enumerations as a single concatenated enumeration.
/// sources: The input enumeration-of-enumerations.
val concat : sources:seq<'Collection> -> seq<'T> when 'Collection :> seq<'T>
/// Tests if the sequence contains the specified element.
/// value: The value to locate in the input sequence.
/// source: The input sequence.
val inline contains : value:'T -> source:seq<'T> -> bool when 'T : equality
/// Applies a key-generating function to each element of a sequence and returns a sequence yielding unique keys and their number of occurrences in the original sequence.
/// projection: A function transforming each item of the input sequence into a key to be compared against the others.
/// source: The input sequence.
val countBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'Key * int> when 'Key : equality
/// Returns a sequence that is built from the given delayed specification of a sequence.
/// generator: The generating function for the sequence.
val delay : generator:(unit -> seq<'T>) -> seq<'T>
/// Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries.  If an element occurs multiple times in the sequence then the later occurrences are discarded.
/// source: The input sequence.
val distinct : source:seq<'T> -> seq<'T> when 'T : equality
/// Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function.  If an element occurs multiple times in the sequence then the later occurrences are discarded.
/// projection: A function transforming the sequence items into comparable keys.
/// source: The input sequence.
val distinctBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> when 'Key : equality
/// Splits the input sequence into at most count chunks.
/// count: The maximum number of chunks.
/// source: The input sequence.
val splitInto : count:int -> source:seq<'T> -> seq<'T []>
/// Creates an empty sequence.
val empty : seq<'T>
/// Returns a new sequence with the distinct elements of the second sequence which do not appear in the first sequence, using generic hash and equality comparisons to compare values.
/// itemsToExclude: A sequence whose elements that also occur in the second sequence will cause those elements to be removed from the returned sequence.
/// source: A sequence whose elements that are not also in first will be returned.
val except : itemsToExclude:seq<'T> -> source:seq<'T> -> seq<'T> when 'T : equality
/// Tests if any element of the sequence satisfies the given predicate.
/// predicate: A function to test each item of the input sequence.
/// source: The input sequence.
val exists : predicate:('T -> bool) -> source:seq<'T> -> bool
/// Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.
/// predicate: A function to test each pair of items from the input sequences.
/// source1: The first input sequence.
/// source2: The second input sequence.
val exists2 : predicate:('T1 -> 'T2 -> bool) -> source1:seq<'T1> -> source2:seq<'T2> -> bool
/// Returns a new collection containing only the elements of the collection for which the given predicate returns "true". This is a synonym for Seq.where.
/// predicate: A function to test whether each item in the input sequence should be included in the output.
/// source: The input sequence.
val filter : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>
/// Returns a new collection containing only the elements of the collection for which the given predicate returns "true".
/// predicate: A function to test whether each item in the input sequence should be included in the output.
/// source: The input sequence.
val where : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>
/// Returns the first element for which the given function returns true.
/// predicate: A function to test whether an item in the sequence should be returned.
/// source: The input sequence.
val find : predicate:('T -> bool) -> source:seq<'T> -> 'T
/// Returns the last element for which the given function returns true.
/// predicate: A function to test whether an item in the sequence should be returned.
/// source: The input sequence.
val findBack : predicate:('T -> bool) -> source:seq<'T> -> 'T
/// Returns the index of the first element for which the given function returns true.
/// predicate: A function to test whether the index of a particular element should be returned.
/// source: The input sequence.
val findIndex : predicate:('T -> bool) -> source:seq<'T> -> int
/// Returns the index of the last element for which the given function returns true.
/// predicate: A function to test whether the index of a particular element should be returned.
/// source: The input sequence.
val findIndexBack : predicate:('T -> bool) -> source:seq<'T> -> int
/// Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN then computes f (... (f s i0)...) iN
/// folder: A function that updates the state with each element from the sequence.
/// state: The initial state.
/// source: The input sequence.
val fold : folder:('State -> 'T -> 'State) -> state:'State -> source:seq<'T> -> 'State
/// Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The two sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.  If the input function is f and the elements are i0...iN and j0...jN then computes f (... (f s i0 j0)...) iN jN.
/// folder: The function to update the state given the input elements.
/// state: The initial state.
/// source1: The first input sequence.
/// source2: The second input sequence.
val fold2 : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> source1:seq<'T1> -> source2:seq<'T2> -> 'State
/// Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN then computes f i0 (... (f iN s)...)
/// folder: The function to update the state given the input elements.
/// source: The input sequence.
/// state: The initial state.
val foldBack : folder:('T -> 'State -> 'State) -> source:seq<'T> -> state:'State -> 'State
/// Applies a function to corresponding elements of two collections, starting from the end of the shorter collection, threading an accumulator argument through the computation. The two sequences need not have equal lengths.  If the input function is f and the elements are i0...iN and j0...jM, N < M then computes f i0 j0 (... (f iN jN s)...).
/// folder: The function to update the state given the input elements.
/// source1: The first input sequence.
/// source2: The second input sequence.
/// state: The initial state.
val foldBack2 : folder:('T1 -> 'T2 -> 'State -> 'State) -> source1:seq<'T1> -> source2:seq<'T2> -> state:'State -> 'State
/// Tests if all elements of the sequence satisfy the given predicate.
/// predicate: A function to test an element of the input sequence.
/// source: The input sequence.
val forall : predicate:('T -> bool) -> source:seq<'T> -> bool
/// Tests the all pairs of elements drawn from the two sequences satisfy the given predicate. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.
/// predicate: A function to test pairs of elements from the input sequences.
/// source1: The first input sequence.
/// source2: The second input sequence.
val forall2 : predicate:('T1 -> 'T2 -> bool) -> source1:seq<'T1> -> source2:seq<'T2> -> bool
/// Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key contains a sequence of all elements that match to this key.
/// projection: A function that transforms an element of the sequence into a comparable key.
/// source: The input sequence.
val groupBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'Key * seq<'T>> when 'Key : equality
/// Returns the first element of the sequence.
/// source: The input sequence.
val head : source:seq<'T> -> 'T
/// Returns the first element of the sequence, or None if the sequence is empty.
/// source: The input sequence.
val tryHead : source:seq<'T> -> 'T option
/// Returns the last element of the sequence.
/// source: The input sequence.
val last : source:seq<'T> -> 'T
/// Returns the last element of the sequence.  Return None if no such element exists.
/// source: The input sequence.
val tryLast : source:seq<'T> -> 'T option
/// Returns the only element of the sequence.
/// source: The input sequence.
val exactlyOne : source:seq<'T> -> 'T
/// Returns true if the sequence contains no elements, false otherwise.
/// source: The input sequence.
val isEmpty : source:seq<'T> -> bool
/// Builds a new collection whose elements are the corresponding elements of the input collection paired with the integer index (from 0) of each element.
/// source: The input sequence.
val indexed : source:seq<'T> -> seq<int * 'T>
/// Generates a new sequence which, when iterated, will return successive elements by calling the given function, up to the given count. Each element is saved after its initialization. The function is passed the index of the item being generated.
/// count: The maximum number of items to generate for the sequence.
/// initializer: A function that generates an item in the sequence from a given index.
val init : count:int -> initializer:(int -> 'T) -> seq<'T>
/// Generates a new sequence which, when iterated, will return successive elements by calling the given function. The results of calling the function will not be saved, that is the function will be reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.
/// initializer: A function that generates an item in the sequence from a given index.
val initInfinite : initializer:(int -> 'T) -> seq<'T>
/// Computes the element at the specified index in the collection.
/// index: The index of the element to retrieve.
/// source: The input sequence.
val item : index:int -> source:seq<'T> -> 'T
/// Applies the given function to each element of the collection.
/// action: A function to apply to each element of the sequence.
/// source: The input sequence.
val iter : action:('T -> unit) -> source:seq<'T> -> unit
/// Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.
/// action: A function to apply to each element of the sequence that can also access the current index.
/// source: The input sequence.
val iteri : action:(int -> 'T -> unit) -> source:seq<'T> -> unit
/// Applies the given function to two collections simultaneously. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.
/// action: A function to apply to each pair of elements from the input sequences.
/// source1: The first input sequence.
/// source2: The second input sequence.
val iter2 : action:('T1 -> 'T2 -> unit) -> source1:seq<'T1> -> source2:seq<'T2> -> unit
/// Applies the given function to two collections simultaneously. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored. The integer passed to the function indicates the index of element.
/// action: A function to apply to each pair of elements from the input sequences along with their index.
/// source1: The first input sequence.
/// source2: The second input sequence.
val iteri2 : action:(int -> 'T1 -> 'T2 -> unit) -> source1:seq<'T1> -> source2:seq<'T2> -> unit
/// Returns the length of the sequence
/// source: The input sequence.
val length : source:seq<'T> -> int
/// Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The given function will be applied as elements are demanded using the MoveNext method on enumerators retrieved from the object.
/// mapping: A function to transform items from the input sequence.
/// source: The input sequence.
val map : mapping:('T -> 'U) -> source:seq<'T> -> seq<'U>
/// Builds a new collection whose elements are the results of applying the given function to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than the other then the remaining elements of the longer sequence are ignored.
/// mapping: A function to transform pairs of items from the input sequences.
/// source1: The first input sequence.
/// source2: The second input sequence.
val map2 : mapping:('T1 -> 'T2 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> seq<'U>
/// Combines map and fold. Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The function is also used to accumulate a final value.
/// mapping: The function to transform elements from the input collection and accumulate the final value.
/// state: The initial state.
/// array: The input collection.
val mapFold : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> source:seq<'T> -> seq<'Result> * 'State
/// Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The function is also used to accumulate a final value.
/// mapping: The function to transform elements from the input collection and accumulate the final value.
/// array: The input collection.
/// state: The initial state.
val mapFoldBack : mapping:('T -> 'State -> 'Result * 'State) -> source:seq<'T> -> state:'State -> seq<'Result> * 'State
/// Builds a new collection whose elements are the results of applying the given function to the corresponding triples of elements from the three sequences. If one input sequence if shorter than the others then the remaining elements of the longer sequences are ignored.
/// mapping: The function to transform triples of elements from the input sequences.
/// source1: The first input sequence.
/// source2: The second input sequence.
/// source3: The third input sequence.
val map3 : mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> source3:seq<'T3> -> seq<'U>
/// Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.
/// mapping: A function to transform items from the input sequence that also supplies the current index.
/// source: The input sequence.
val mapi : mapping:(int -> 'T -> 'U) -> source:seq<'T> -> seq<'U>
/// Builds a new collection whose elements are the results of applying the given function to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than the other then the remaining elements of the longer sequence are ignored. The integer index passed to the function indicates the index (from 0) of element being transformed.
/// mapping: A function to transform pairs of items from the input sequences that also supplies the current index.
/// source1: The first input sequence.
/// source2: The second input sequence.
val mapi2 : mapping:(int -> 'T1 -> 'T2 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> seq<'U>
/// Returns the greatest of all elements of the sequence, compared via Operators.max
/// source: The input sequence.
val inline max : source:seq<'T> -> 'T when 'T : comparison
/// Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.
/// projection: A function to transform items from the input sequence into comparable keys.
/// source: The input sequence.
val inline maxBy : projection:('T -> 'U) -> source:seq<'T> -> 'T when 'U : comparison
/// Returns the lowest of all elements of the sequence, compared via Operators.min.
/// source: The input sequence.
val inline min : source:seq<'T> -> 'T when 'T : comparison
/// Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.
/// projection: A function to transform items from the input sequence into comparable keys.
/// source: The input sequence.
val inline minBy : projection:('T -> 'U) -> source:seq<'T> -> 'T when 'U : comparison
/// Computes the nth element in the collection.
/// index: The index of element to retrieve.
/// source: The input sequence.
val nth : index:int -> source:seq<'T> -> 'T
/// Views the given array as a sequence.
/// source: The input array.
val ofArray : source:'T [] -> seq<'T>
/// Views the given list as a sequence.
/// source: The input list.
val ofList : source:'T list -> seq<'T>
/// Returns a sequence of each element in the input sequence and its predecessor, with the exception of the first element which is only returned as the predecessor of the second element.
/// source: The input sequence.
val pairwise : source:seq<'T> -> seq<'T * 'T>
/// Returns a sequence with all elements permuted according to the specified permutation.
/// indexMap: The function that maps input indices to output indices.
/// source: The input sequence.
val permute : indexMap:(int -> int) -> source:seq<'T> -> seq<'T>
/// Applies the given function to successive elements, returning the first x where the function returns "Some(x)".
/// chooser: A function to transform each item of the input sequence into an option of the output type.
/// source: The input sequence.
val pick : chooser:('T -> 'U option) -> source:seq<'T> -> 'U
/// Builds a new sequence object that delegates to the given sequence object. This ensures the original sequence cannot be rediscovered and mutated by a type cast. For example, if given an array the returned sequence will return the elements of the array, but you cannot cast the returned sequence object to an array.
/// source: The input sequence.
val readonly : source:seq<'T> -> seq<'T>
/// Applies a function to each element of the sequence, threading an accumulator argument through the computation. Begin by applying the function to the first two elements.  Then feed this result into the function along with the third element and so on. Return the final result.
/// reduction: A function that takes in the current accumulated result and the next element of the sequence to produce the next accumulated result.
/// source: The input sequence.
val reduce : reduction:('T -> 'T -> 'T) -> source:seq<'T> -> 'T
/// Creates a sequence by replicating the given initial value.
/// count: The number of elements to replicate.
/// initial: The value to replicate
val replicate : count:int -> initial:'T -> seq<'T>
/// Applies a function to each element of the sequence, starting from the end, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN then computes f i0 (...(f iN-1 iN)).
/// reduction: A function that takes in the next-to-last element of the sequence and the current accumulated result to produce the next accumulated result.
/// source: The input sequence.
val reduceBack : reduction:('T -> 'T -> 'T) -> source:seq<'T> -> 'T
/// Returns a new sequence with the elements in reverse order.
/// source: The input sequence.
val rev : source:seq<'T> -> seq<'T>
/// Like fold, but computes on-demand and returns the sequence of intermediary and final results.
/// folder: A function that updates the state with each element from the sequence.
/// state: The initial state.
/// source: The input sequence.
val scan : folder:('State -> 'T -> 'State) -> state:'State -> source:seq<'T> -> seq<'State>
/// Like foldBack, but returns the sequence of intermediary and final results.
/// folder: A function that updates the state with each element from the sequence.
/// source: The input sequence.
/// state: The initial state.
val scanBack : folder:('T -> 'State -> 'State) -> source:seq<'T> -> state:'State -> seq<'State>
/// Returns a sequence that yields one item only.
/// value: The input item.
val singleton : value:'T -> seq<'T>
/// Returns a sequence that skips N elements of the underlying sequence and then yields the remaining elements of the sequence.
/// count: The number of items to skip.
/// source: The input sequence.
val skip : count:int -> source:seq<'T> -> seq<'T>
/// Returns a sequence that, when iterated, skips elements of the underlying sequence while the given predicate returns true, and then yields the remaining elements of the sequence.
/// predicate: A function that evaluates an element of the sequence to a boolean value.
/// source: The input sequence.
val skipWhile : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>
/// Yields a sequence ordered by keys.
/// source: The input sequence.
val sort : source:seq<'T> -> seq<'T> when 'T : comparison
/// Yields a sequence ordered using the given comparison function.
/// comparer: The function to compare the collection elements.
/// list: The input sequence.
val sortWith : comparer:('T -> 'T -> int) -> source:seq<'T> -> seq<'T>
/// Applies a key-generating function to each element of a sequence and yield a sequence ordered by keys. The keys are compared using generic comparison as implemented by Operators.compare.
/// projection: A function to transform items of the input sequence into comparable keys.
/// source: The input sequence.
val sortBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> when 'Key : comparison
/// Yields a sequence ordered descending by keys.
/// source: The input sequence.
val inline sortDescending : source:seq<'T> -> seq<'T> when 'T : comparison
/// Applies a key-generating function to each element of a sequence and yield a sequence ordered descending by keys. The keys are compared using generic comparison as implemented by Operators.compare.
/// projection: A function to transform items of the input sequence into comparable keys.
/// source: The input sequence.
val inline sortByDescending : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> when 'Key : comparison
/// Returns the sum of the elements in the sequence.
/// source: The input sequence.
val inline sum : source:seq< ^T> ->  ^T when ^T : (static member ( + ) :  ^T *  ^T ->  ^T) and ^T : (static member Zero :  ^T)
/// Returns the sum of the results generated by applying the function to each element of the sequence.
/// projection: A function to transform items from the input sequence into the type that will be summed.
/// source: The input sequence.
val inline sumBy : projection:('T ->  ^U) -> source:seq<'T> ->  ^U when ^U : (static member ( + ) :  ^U *  ^U ->  ^U) and ^U : (static member Zero :  ^U)
/// Returns a sequence that skips 1 element of the underlying sequence and then yields the remaining elements of the sequence.
/// source: The input sequence.
val tail : source:seq<'T> -> seq<'T>
/// Returns the first N elements of the sequence.
/// count: The number of items to take.
/// source: The input sequence.
val take : count:int -> source:seq<'T> -> seq<'T>
/// Returns a sequence that, when iterated, yields elements of the underlying sequence while the given predicate returns true, and then returns no further elements.
/// predicate: A function that evaluates to false when no more items should be returned.
/// source: The input sequence.
val takeWhile : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>
/// Builds an array from the given collection.
/// source: The input sequence.
val toArray : source:seq<'T> -> 'T []
/// Builds a list from the given collection.
/// source: The input sequence.
val toList : source:seq<'T> -> 'T list
/// Returns the first element for which the given function returns true.  Return None if no such element exists.
/// predicate: A function that evaluates to a Boolean when given an item in the sequence.
/// source: The input sequence.
val tryFind : predicate:('T -> bool) -> source:seq<'T> -> 'T option
/// Returns the last element for which the given function returns true.  Return None if no such element exists.
/// predicate: A function that evaluates to a Boolean when given an item in the sequence.
/// source: The input sequence.
val tryFindBack : predicate:('T -> bool) -> source:seq<'T> -> 'T option
/// Returns the index of the first element in the sequence that satisfies the given predicate. Return None if no such element exists.
/// predicate: A function that evaluates to a Boolean when given an item in the sequence.
/// source: The input sequence.
val tryFindIndex : predicate:('T -> bool) -> source:seq<'T> -> int option
/// Tries to find the nth element in the sequence.  Returns None if index is negative or the input sequence does not contain enough elements.
/// index: The index of element to retrieve.
/// source: The input sequence.
val tryItem : index:int -> source:seq<'T> -> 'T option
/// Returns the index of the last element in the sequence that satisfies the given predicate. Return None if no such element exists.
/// predicate: A function that evaluates to a Boolean when given an item in the sequence.
/// source: The input sequence.
val tryFindIndexBack : predicate:('T -> bool) -> source:seq<'T> -> int option
/// Applies the given function to successive elements, returning the first result where the function returns "Some(x)".
/// chooser: A function that transforms items from the input sequence into options.
/// source: The input sequence.
val tryPick : chooser:('T -> 'U option) -> source:seq<'T> -> 'U option
/// Returns a sequence that when enumerated returns at most N elements.
/// count: The maximum number of items to enumerate.
/// source: The input sequence.
val truncate : count:int -> source:seq<'T> -> seq<'T>
/// Returns a sequence that contains the elements generated by the given computation.  The given initial state argument is passed to the element generator.  For each IEnumerator elements in the stream are generated on-demand by applying the element generator, until a None value is returned by the element generator. Each call to the element generator returns a new residual state.
/// generator: A function that takes in the current state and returns an option tuple of the next element of the sequence and the next state value.
/// state: The initial state value.
val unfold : generator:('State -> ('T * 'State) option) -> state:'State -> seq<'T>
/// Returns a sequence that yields sliding windows containing elements drawn from the input sequence. Each window is returned as a fresh array.
/// windowSize: The number of elements in each window.
/// source: The input sequence.
val windowed : windowSize:int -> source:seq<'T> -> seq<'T []>
/// Combines the two sequences into a list of pairs. The two sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.
/// source1: The first input sequence.
/// source2: The second input sequence.
val zip : source1:seq<'T1> -> source2:seq<'T2> -> seq<'T1 * 'T2>
/// Combines the three sequences into a list of triples. The sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequences are ignored.
/// source1: The first input sequence.
/// source2: The second input sequence.
/// source3: The third input sequence.
val zip3 : source1:seq<'T1> -> source2:seq<'T2> -> source3:seq<'T3> -> seq<'T1 * 'T2 * 'T3>
