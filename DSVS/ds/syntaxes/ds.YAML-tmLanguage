---
# from INK

name: ds
scopeName: source.ds
fileTypes: [ds, ds]
foldingStartMarker: '\{\s*$'
foldingStopMarker: '^\s*\}'

# foldingStartMarker: '^\s*[{\[\`](?!.*[}\]\`],?\s*$)|[{\[\`]\s*$'
# foldingStopMarker: '^\s*[}\]\`]'

# 원본 참조
# https://github.com/inkle/ink-tmlanguage/blob/master/grammars/Ink.YAML-tmLanguage

variables:
#   # # Identifier can't start with a number…
#   indentifierBeginCharacter: '[a-zA-Z_\x{0100}-\x{017F}\x{0180}-\x{024F}\x{0600}-\x{06FF}\x{0530}-\x{058F}\x{0400}-\x{04FF}\x{0370}-\x{03FF}\x{0590}-\x{05FF}]'
#   # Identifier characters can anything within these unicode blocks
#   indentifierCharacter: '[a-zA-Z0-9_\x{0100}-\x{017F}\x{0180}-\x{024F}\x{0600}-\x{06FF}\x{0530}-\x{058F}\x{0400}-\x{04FF}\x{0370}-\x{03FF}\x{0590}-\x{05FF}]'

#   anyNonIdentifierCharacter: '[^a-zA-Z_\x{0100}-\x{017F}\x{0180}-\x{024F}\x{0600}-\x{06FF}\x{0530}-\x{058F}\x{0400}-\x{04FF}\x{0370}-\x{03FF}\x{0590}-\x{05FF}]'
#   validIdentifier: '{{indentifierCharacter}}*{{indentifierBeginCharacter}}{{indentifierCharacter}}*'

#   standardFunctions: 'LIST_COUNT|LIST_MIN|LIST_MAX|LIST_ALL|LIST_INVERT|LIST_RANDOM|CHOICE_COUNT|TURNS_SINCE|LIST_RANGE|TURNS|POW|FLOOR|CEILING|INT|FLOAT'
  whitespace: '[^\S\n\r]'
  accSRE: 'accSRE|accSR|accRE|accSE|accS|accR|accE'

#   segmentName: '[:alpha]([:alnum])*(.[:alnum]+){1}'

# - include: '#import'
# - include: '#declaration'
# - include: '#knot'
# - include: '#stitch'
# - include: '#choice'
# - include: '#divert'
# - include: '#gather'
# - include: '#logic'
# - include: '#glue'
# - include: '#interpolevaluablock'

# - include: '#todo'
# - include: '#property'
patterns:
- include: '#comments'
- include: '#systems'
# - include: '#definitions'
# - include: '#segments'
# - include: '#segment'
# - include: '#properties'
- include: '#dquoted'

repository:

# ##############################################################################
# Comments
# ##############################################################################

  comments: # Inline (//) and block (/* */) comments. Comments can happen anywhere.
    patterns:
    - name: comment.block.ds
      begin: (/\*)
      beginCaptures:
        '1': { name: 'punctuation.definition.comment.ds' }
      end: (\*/)
      endCaptures:
        '1': { name: 'punctuation.definition.comment.ds' }
    - name: comment.line.ds
      begin: (\/\/)
      beginCaptures:
        '1': { name: 'punctuation.definition.comment.ds' }
      end: (?=$)

  systems:
    patterns:
      - comment: multi-line
        name: system.multi.ds
        begin: \[\s*(Sys)\s*\]\s*([a-zA-Z_][a-zA-Z_0-9]*)\s*=\s*(\{)(?=[^\}]*$)
        beginCaptures:
          '1': {name: keyword.control.ds}
          '2': {name: keyword.control.ds}
        end: (\})
        endCaptures:
          '1': {name: punctuation.brace.end.ds}
        patterns:          
        - include: '#comments'
        - include: '#accessDefs'
        - include: '#macros'
        # - include: '#braceLists'
      - comment: single-line
        name: system.single.ds
        begin: \[\s*(Sys)\s*\]\s*([a-zA-Z_][a-zA-Z_0-9]*)\s*=\s*\{
        beginCaptures:
          '1': {name: keyword.control.ds}
          '2': {name: keyword.control.ds}
        end: \}
        patterns:          
        - name: punctuation.separator.array.ds
          match: ";"
        - include: '#segment'
        - name: invalid.illegal.expected-array-separator.json
          match: '[^\s\}]'
        # - include: '#comments'

  braceLists:
    patterns:
      - name: system.braceLists.ds
        begin: (\{)
        beginCaptures:
          '1': {name: punctuation.brace.start.ds}
        end: (\})
        endCaptures:
          '1': {name: punctuation.brace.end.ds}
        patterns:
          - include: '#segment'
          - name: punctuation.brace.separator.ds
            match: ;

  accessDefs:
    patterns:
    - name: access.ds
      begin: \[\s*(accSRE|accSR|accRE|accSE|accS|accR|accE)\s*\]\s*=\s*(\{)
      beginCaptures:
        '1': {name: keyword.control.accessSRE.ds}      
      end: (\})
      patterns:
        - name: punctuation.brace.separator.ds
          match: ;
        - include: '#segment'
        - include: '#comments'
    - include: '#comments'
    - include: $self

  macros:
    patterns:
    - name: macro2.ds
      begin: \[\s*(macro)\s*(=\s*([a-zA-Z_][a-zA-Z_0-9]*))?\s*\]\s*=\s*(\{)
      beginCaptures:
        '1': {name: keyword.control.macro2.ds}      
        '3': {name: keyword.control.macro.var.ds}      
      end: (\})
      patterns:
        #- name: punctuation.brace.separator.ds
        #   match: ;
        - include: '#callSegmentDefs'
        - include: '#comments'

  callSegmentDefs:
    patterns:
    - name: call.segment.ds
      begin: ([a-zA-Z_][a-zA-Z_0-9]*)\s*=\s*(\{)
      beginCaptures:
        '1': {name: keyword.control.callSegment.ds}
      end: (\})
      patterns:
        - name: punctuation.comma.ds
          match: ','
        - name: punctuation.tilde.ds
          match: '~'
        - include: '#segment'


  segment:
    patterns:
    - name: 'variable.other.segment.withdot.ds'
      # match: '\b\w+(\.\w+)\b'
      match: '\b[a-zA-Z_][a-zA-Z_0-9]*\.[a-zA-Z_][a-zA-Z_0-9]*\b'
    - name: 'variable.other.segment.ds'
      # match: '\b\w+\b'
      # match: '{{segmentName}}'
      # match: '([a-zA-Z_][:alnum:]*)|([a-zA-Z_][:alnum:]*\.[a-zA-Z_][:alnum:]*)'
      match: '\b[a-zA-Z_][a-zA-Z_0-9]*\b'
    - include: '#comments'
    - name: invalid.illegal.expected-array-separator.json
      match: '[^\s\{\};=<>\|&~\(\)]'


  segments:
    - name: meta.structure.array.ds
      begin: (\{)
      beginCaptures:
        '1': { name: 'punctuation.definition.macro.start.ds' }
      end: (\})
      endCaptures:
        '1': { name: 'punctuation.definition.macro.end.ds' } 
      patterns:
      - name: punctuation.separator.array.ds
        match: ";"
      - name: invalid.illegal.expected-array-separator.json
        match: '[^\s\]]'
      - include: '#comments'
      - include: '#segment'


  # definitions:
  #   patterns:
  #     - include: '#properties'
  #     - name: punctuation.separator.define.ds
  #     - match: '{{properties}}{{segment}}\s*={{segments}}\b'
  #     - include: '#segments'


  dquoted:
    patterns:
    - name: 'string.quoted.double.untitled'
      begin: (")
      end: (")
      patterns:
      - name: 'constant.character.escape.untitled'
        match: '\\.'




...